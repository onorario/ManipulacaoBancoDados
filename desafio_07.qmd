---
title: "Desafio_07"
author: "Luiz Fernando de Oliveira Pereira RA:267356"
format: 
  html:
    self-contained: true
editor: visual
---

## Quarto

Inserindo Dados

```{r}
library(RSQLite)
library(tidyverse)
if(!"discoCopy.db" %in% list.files("dados/")){
file.copy("dados/disco.db"
,
"dados/discoCopy.db")
} # Modificaremos esse arquivo

```

```{r}
db <- dbConnect(SQLite(),
"dados/discoCopy.db")

```

Inserindo uma tabela

```{r}
# Neste momento, existem as seguintes tabelas em disco.db:
dbListTables(db)

```

```{r}
#A sintaxe para criar uma tabela vazia, no SQLite, é através do comando
#CREATE TABLE nome (col1 tipo, col2 tipo2, ...)
dbExecute(db,
"CREATE TABLE instruments
(AlbumId INTEGER,
TrackId INTEGER,
ElectricGuitar INTEGER,
Singer INTEGER,
Trumpet INTEGER)")

```

Removendo uma tabela

```{r}
# Removendo uma tabela
dbListFields(db,'instruments')

# Removendo uma tabela usando o comando DROP TABLE nome:
dbExecute(db,
"DROP TABLE instruments")

dbListTables(db)

```

Bestpractices

```{r}

#Um exemplo de um aplicativo que colhe inputs do usuário em aname e diz quais álbums deste artista estão listados:

aname = "Gilberto Gil"
sql = paste0("SELECT ArtistId FROM artists "
,
"WHERE Name = '"
, aname,
"'")
aId = dbGetQuery(db, sql)
sql = paste('SELECT Title FROM albums'
,
'WHERE ArtistId ='
, aId)
dbGetQuery(db, sql)

```

```{r}
#Um usuário malicioso pode inserir algo como
#Esse código está simulando uma injeção SQL — ele cria uma string que, se usada ingenuamente numa query, poderia apagar a tabela albums.

aname <- "Gilberto Gil'; DROP TABLE 'albums"
aname
```

Incluindo linhas numa tabela

```{r}

dbExecute(db,
"CREATE TABLE instruments
(AlbumId INTEGER,
TrackId INTEGER,
ElectricGuitar INTEGER,
Singer INTEGER,
Trumpet INTEGER)")

dbListFields(db,'instruments')



```

```{r}

#Selecionando as colunas Trackid e Name da tabela tracks, em que AlbumId = 85
# Eu Tu Eles: AlbumId 85,
sql = paste('SELECT TrackId, Name FROM tracks'
,
'WHERE AlbumId = 85')
dbGetQuery(db, sql) %>% head

```

Incluindo linhas numa tabela

```{r}
#Adicionando a coluna VALUES no data frame instruments
dbExecute(db,"INSERT INTO instruments
                VALUES ('85','1075', 0, 1, 0),
                       ('85','1078', 0, 1, 0); ")
```

```{r}
#Selecionando o data frame instruments
dbGetQuery(db,
"SELECT * FROM instruments")

```

Inserindo uma tabela diretamente

```{r}
#Adicionando o data.frame mtcars no banco de dados db
dbWriteTable(db,"mtcars", mtcars)
#dbListTables(db)


```

```{r}
dbListTables(db)
```

```{r}
dbGetQuery(db,
"SELECT * FROM mtcars") %>% head(3)
#Pegamos todas a colunas de mtcars e mostramos apenas as 3 primeiras linhas
```

Inserindo uma tabela diretamente:append

```{r}
#O parâmetro append concatena uma tabela nova a dados existentes. Por exemplo,

theAvgCar <- mtcars %>%
summarise_all(function(x) round(mean(x), 2))
theAvgCar
#Para mtcars e plica uma função de resumo a todas as colunas numéricas do mtcars, depois para cada coluna calcula a média e arredonda em 2 casas decimais

```

```{r}


dbWriteTable(db,"mtcars", theAvgCar, append = TRUE) 
#Adicionamos uma nova linha (theAvgCar) a tabela mtcars dentro do banco de dados.
dbGetQuery(db,"SELECT * FROM mtcars") %>% tail(3)
#Mostra as 3 últimas linhas do data frame mtcars

```

Inserindo uma tabela diretamente:overwrite

```{r}
dbWriteTable(db,"mtcars", mtcars, overwrite = TRUE)
dbGetQuery(db,"SELECT * FROM mtcars") %>% tail(3)

#A diferença aqui é que o parâmetro overwrite sobrescreve a tabela

#append = TRUE → adiciona novas linhas à tabela existente, preservando o que já havia.

#overwrite = TRUE → substitui a tabela inteira por uma nova, apagando tudo o que havia antes.

```

Lendo chunks

```{r}
#Em certo sentido, dbGetQuery() é um atalho para dbSendQuery() seguido de dbFetch() (e dbClearResult()). Uma vantagem de usar a sintaxe mais longa é que podemos ler dados em chunks:


#selecionando todos os carros (*) da tabela mtcars com 4 cilindros (cyl = 4).
res <- dbSendQuery(db,
"SELECT * FROM mtcars WHERE cyl = 4")
while(!dbHasCompleted(res)){
chunk <- dbFetch(res, n = 5)
print(nrow(chunk))
}

#dbHasCompleted(res) → retorna TRUE quando já não há mais linhas a buscar.
# O ! nega → então o laço continua enquanto ainda restarem linhas a trazer.
```

```{r}
dbClearResult(res)
```

Fechando conexões

```{r}
#Encerrando conexão com dbDisconnect() e apagando a a cópia da database disco.db.


dbDisconnect(db)
if("discoCopy.db" %in% list.files("dados/")){
file.remove("dados/discoCopy.db")
}
```

Criando sua base de dados

```{r}
#Lendo os banco de dados airports e airlines
airports <- read_csv("dados/airports.csv", col_types = "cccccdd")
airlines <- read_csv("dados/airlines.csv", col_types = "cc")

#Criando uma noma base de dados em air
air <- dbConnect(SQLite(), dbname="dados/air.db")
dbWriteTable(air, name = "airports", airports)
dbWriteTable(air, name = "airlines", airlines)
dbListTables(air)

```

```{r}
#Você também pode usar a função copy_to(conn, df) do dplyr! A sintaxe é parecida


```

```{r}
#Desconectando e removendo a tabela air.
dbDisconnect(air)
if("air.db" %in% list.files("dados/")){
file.remove("dados/air.db")
}

```

Breve introdução ao dbplyr

```{r}
#O pacote dbplyr estende algumas funcionalidades do dplyr a dados que estão armazenados em um bancos de dados externo.
library(RSQLite)
library(tidyverse)
library(dbplyr)


db <- dbConnect(SQLite(),"dados/disco.db") # original
tracks <- tbl(db,"tracks") # dplyr
tracks %>% head(3)



```

Verbosdo dplyr disponíveis...

```{r}

#Agrupando linhas por AlbumID de tracks, com summarise criamos um novo data frame agrupando por AlbumID, em Avlen eu calculo a média dos Milliseconds e em AVCost eu cálculo a média de UnitPrice

meanTracks <- tracks %>%
  group_by(AlbumId) %>%
  summarise(AvLen = mean(Milliseconds, na.rm = TRUE),
          AvCost = mean(UnitPrice, na.rm = TRUE))
meanTracks

```

...mas secretamente, são comandos de SQLite!

```{r}

#show_query() não executa nada, apenas mostra o SQL equivalente à manipulação feita com dplyr, permitindo ver como o R traduz os verbos (group_by, summarise, etc.) em SQL.
meanTracks %>% show_query()
```

Consulta, de fato

```{r}
#collect() materializa os resultados da query no R, convertendo o objeto de consulta em um data.frame/tibble normal, que você pode usar como qualquer outro dataset do R.
mT <- meanTracks %>% collect()
mT

```

```{r}
#Desconectando
dbDisconnect(db)
```
